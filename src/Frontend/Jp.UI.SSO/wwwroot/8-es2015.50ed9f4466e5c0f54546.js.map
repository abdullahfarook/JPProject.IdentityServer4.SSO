{"version":3,"sources":["./node_modules/@ng-stack/forms/fesm2015/ng-stack-forms.js.pre-build-optimizer.js","./src/app/shared/components/input-validation/input-validation.ngfactory.js.pre-build-optimizer.js","./src/app/shared/components/input-validation/input-validation.html","./src/app/shared/components/input-validation/input-validation.ts","./src/app/shared/directives/numberCheck/numbers-only.directive.ts","./src/app/shared/validators/form.utils.ts"],"names":[],"mappings":"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","file":"8-es2015.50ed9f4466e5c0f54546.js","sourcesContent":["import { __decorate, __metadata } from 'tslib';\nimport { Injectable, EventEmitter, ElementRef, Renderer2, Input, Output, HostListener, Directive, forwardRef, NgModule } from '@angular/core';\nimport { FormBuilder as FormBuilder$1, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormArray as FormArray$1, FormControl as FormControl$1, FormGroup as FormGroup$1, Validators as Validators$1 } from '@angular/forms';\n\nlet FormBuilder = class FormBuilder extends FormBuilder$1 {\n    /**\n     * Construct a new `FormGroup` instance.\n     *\n     * @param controlsConfig A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param options Configuration options object for the `FormGroup`. The object can\n     * have two shapes:\n     *\n     * 1) `AbstractControlOptions` object (preferred), which consists of:\n     * - `validators`: A synchronous validator function, or an array of validator functions\n     * - `asyncValidators`: A single async validator or array of async validator functions\n     * - `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\n     * submit')\n     *\n     * 2) Legacy configuration object, which consists of:\n     * - `validator`: A synchronous validator function, or an array of validator functions\n     * - `asyncValidator`: A single async validator or array of async validator functions\n     */\n    group(controlsConfig, options = null) {\n        return super.group(controlsConfig, options);\n    }\n    /**\n     * @description\n     * Construct a new `FormControl` with the given state, validators and options.\n     *\n     * @param formState Initializes the control with an initial state value, or\n     * with an object that contains both a value and a disabled status.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator\n     * functions.\n     *\n     * ### Initialize a control as disabled\n     *\n     * The following example returns a control with an initial value in a disabled state.\n  ```ts\n  import {Component, Inject} from '@angular/core';\n  import {FormBuilder, FormControl, FormGroup, Validators} from '@angular/forms';\n  // ...\n  @Component({\n    selector: 'app-disabled-form-control',\n    template: `\n      <input [formControl]=\"control\" placeholder=\"First\">\n    `\n  })\n  export class DisabledFormControlComponent {\n    control: FormControl;\n  \n    constructor(private fb: FormBuilder) {\n      this.control = fb.control({value: 'my val', disabled: true});\n    }\n  }\n  ```\n     */\n    control(formState = null, validatorOrOpts, asyncValidator) {\n        return super.control(formState, validatorOrOpts, asyncValidator);\n    }\n    /**\n     * Constructs a new `FormArray` from the given array of configurations,\n     * validators and options.\n     *\n     * @param controlsConfig An array of child controls or control configs. Each\n     * child control is given an index when it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator\n     * functions.\n     */\n    array(controlsConfig, validatorOrOpts, asyncValidator) {\n        return super.array(controlsConfig, validatorOrOpts, asyncValidator);\n    }\n};\nFormBuilder = __decorate([\n    Injectable()\n], FormBuilder);\n\nvar InputFileDirective_1;\nlet InputFileDirective = InputFileDirective_1 = class InputFileDirective {\n    constructor(elementRef, renderer) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.select = new EventEmitter();\n        this.onChange = (value) => { };\n        this.onTouched = () => { };\n    }\n    /**\n     * Callback function that should be called when\n     * the control's value changes in the UI.\n     */\n    callOnChange(event) {\n        this.onTouched();\n        const files = Array.from(this.elementRef.nativeElement.files);\n        const formData = new FormData();\n        let formInputName = this.elementRef.nativeElement.name || 'uploadFile';\n        if (this.multiple !== undefined && this.multiple !== false && this.multiple !== 'false') {\n            formInputName += '[]';\n        }\n        files.forEach(file => formData.append(formInputName, file));\n        this.onChange(formData);\n        this.select.next(files);\n        event.target.value = null;\n    }\n    /**\n     * Writes a new value to the element.\n     * This method will be called by the forms API to write\n     * to the view when programmatic (model -> view) changes are requested.\n     *\n     * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)\n     */\n    writeValue(fileList) {\n        if (fileList && !(fileList instanceof FileList)) {\n            throw new TypeError('Value for input[type=file] must be an instance of FileList');\n        }\n        this.renderer.setProperty(this.elementRef.nativeElement, 'files', fileList);\n    }\n    /**\n     * Registers a callback function that should be called when\n     * the control's value changes in the UI.\n     *\n     * This is called by the forms API on initialization so it can update\n     * the form model when values propagate from the view (view -> model).\n     */\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    /**\n     * Registers a callback function that should be called when the control receives a change event.\n     * This is called by the forms API on initialization so it can update the form model on change.\n     */\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n};\nInputFileDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 }\n];\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], InputFileDirective.prototype, \"multiple\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", Object)\n], InputFileDirective.prototype, \"select\", void 0);\n__decorate([\n    HostListener('change', ['$event']),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Object]),\n    __metadata(\"design:returntype\", void 0)\n], InputFileDirective.prototype, \"callOnChange\", null);\nInputFileDirective = InputFileDirective_1 = __decorate([\n    Directive({\n        selector: `\n  input[type=file][ngModel],\n  input[type=file][formControl],\n  input[type=file][formControlName]`,\n        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => InputFileDirective_1), multi: true }],\n    }),\n    __metadata(\"design:paramtypes\", [ElementRef, Renderer2])\n], InputFileDirective);\n\nlet NgStackFormsModule = class NgStackFormsModule {\n};\nNgStackFormsModule = __decorate([\n    NgModule({\n        declarations: [InputFileDirective],\n        exports: [ReactiveFormsModule, InputFileDirective],\n        providers: [FormBuilder],\n    })\n], NgStackFormsModule);\n\nclass FormArray extends FormArray$1 {\n    /**\n     * Creates a new `FormArray` instance.\n     *\n     * @param controls An array of child controls. Each child control is given an index\n     * where it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls, validatorOrOpts, asyncValidator) {\n        super(controls, validatorOrOpts, asyncValidator);\n        this.controls = controls;\n    }\n    /**\n     * Get the Control at the given `index` in the array.\n     *\n     * @param index Index in the array to retrieve the control\n     */\n    at(index) {\n        return super.at(index);\n    }\n    /**\n     * Insert a new Control at the end of the array.\n     *\n     * @param control Form control to be inserted\n     */\n    push(control) {\n        return super.push(control);\n    }\n    /**\n     * Insert a new Control at the given `index` in the array.\n     *\n     * @param index Index in the array to insert the control\n     * @param control Form control to be inserted\n     */\n    insert(index, control) {\n        return super.insert(index, control);\n    }\n    /**\n     * Replace an existing control.\n     *\n     * @param index Index in the array to replace the control\n     * @param control The Control control to replace the existing control\n     */\n    setControl(index, control) {\n        return super.setControl(index, control);\n    }\n    /**\n     * Sets the value of the `FormArray`. It accepts an array that matches\n     * the structure of the control.\n     *\n     * This method performs strict checks, and throws an error if you try\n     * to set the value of a control that doesn't exist or if you exclude the\n     * value of a control.\n     *\n     * ### Set the values for the controls in the form array\n     *\n  ```ts\n  const arr = new FormArray([\n    new FormControl(),\n    new FormControl()\n  ]);\n  console.log(arr.value);   // [null, null]\n  \n  arr.setValue(['Nancy', 'Drew']);\n  console.log(arr.value);   // ['Nancy', 'Drew']\n  ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    setValue(value, options = {}) {\n        return super.setValue(value, options);\n    }\n    /**\n     * Patches the value of the `FormArray`. It accepts an array that matches the\n     * structure of the control, and does its best to match the values to the correct\n     * controls in the group.\n     *\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\n     *\n     * ### Patch the values for controls in a form array\n     *\n  ```ts\n  const arr = new FormArray([\n     new FormControl(),\n     new FormControl()\n  ]);\n  console.log(arr.value);   // [null, null]\n  \n  arr.patchValue(['Nancy']);\n  console.log(arr.value);   // ['Nancy', null]\n  ```\n     *\n     * @param value Array of latest values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    patchValue(value, options = {}) {\n        return super.patchValue(value, options);\n    }\n    /**\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n     * value of all descendants to null or null maps.\n     *\n     * You reset to a specific form state by passing in an array of states\n     * that matches the structure of the control. The state is a standalone value\n     * or a form state object with both a value and a disabled status.\n     *\n     * ### Reset the values in a form array\n     *\n  ```ts\n  const arr = new FormArray([\n     new FormControl(),\n     new FormControl()\n  ]);\n  arr.reset(['name', 'last name']);\n  \n  console.log(this.arr.value);  // ['name', 'last name']\n  ```\n     *\n     * ### Reset the values in a form array and the disabled status for the first control\n     *\n  ```\n  this.arr.reset([\n    {value: 'name', disabled: true},\n    'last'\n  ]);\n  \n  console.log(this.arr.value);  // ['name', 'last name']\n  console.log(this.arr.get(0).status);  // 'DISABLED'\n  ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    reset(value = [], options = {}) {\n        return super.reset(value, options);\n    }\n    /**\n     * The aggregate value of the array, including any disabled controls.\n     *\n     * Reports all values regardless of disabled status.\n     * For enabled controls only, the `value` property is the best way to get the value of the array.\n     */\n    getRawValue() {\n        return super.getRawValue();\n    }\n    /**\n     * Sets the synchronous validators that are active on this control. Calling\n     * this overwrites any existing sync validators.\n     */\n    setValidators(newValidator) {\n        return super.setValidators(newValidator);\n    }\n    /**\n     * Sets the async validators that are active on this control. Calling this\n     * overwrites any existing async validators.\n     */\n    setAsyncValidators(newValidator) {\n        return super.setAsyncValidators(newValidator);\n    }\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```ts\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    setErrors(errors, opts = {}) {\n        return super.setErrors(errors, opts);\n    }\n    /**\n     * Reports error data for the control with the given controlName.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n     *\n  ```ts\n  form.get('address').getError('someErrorCode', 'street');\n  ```\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode, controlName) {\n        return super.getError(errorCode, controlName);\n    }\n    /**\n     * Reports whether the control with the given controlName has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n  ```ts\n  form.get('address').hasError('someErrorCode', 'street');\n  ```\n     *\n     * If no controlName is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given controlName.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode, controlName) {\n        return super.hasError(errorCode, controlName);\n    }\n}\n\nclass FormControl extends FormControl$1 {\n    /**\n     * Creates a new `FormControl` instance.\n     *\n     * @param formState Initializes the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(formState = null, validatorOrOpts, asyncValidator) {\n        super(formState, validatorOrOpts, asyncValidator);\n    }\n    /**\n     * Sets a new value for the form control.\n     *\n     * @param value The new value for the control.\n     * @param options Configuration options that determine how the control proopagates changes\n     * and emits events when the value changes.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n     * `onChange` event to\n     * update the view.\n     * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n     * `ngModelChange`\n     * event to update the model.\n     *\n     */\n    setValue(value, options = {}) {\n        return super.setValue(value, options);\n    }\n    /**\n     * Patches the value of a control.\n     *\n     * This function is functionally the same as [setValue](https://angular.io/api/forms/FormControl#setValue) at this level.\n     * It exists for symmetry with [patchValue](https://angular.io/api/forms/FormGroup#patchValue) on `FormGroups` and\n     * `FormArrays`, where it does behave differently.\n     *\n     * See also: `setValue` for options\n     */\n    patchValue(value, options = {}) {\n        return super.patchValue(value, options);\n    }\n    /**\n     * Resets the form control, marking it `pristine` and `untouched`, and setting\n     * the value to null.\n     *\n     * @param formState Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     *\n     */\n    reset(formState = null, options = {}) {\n        return super.reset(formState, options);\n    }\n    /**\n     * In `FormControl`, this method always returns `null`.\n     */\n    get() {\n        return null;\n    }\n    /**\n     * Sets the synchronous validators that are active on this control. Calling\n     * this overwrites any existing sync validators.\n     */\n    setValidators(newValidator) {\n        return super.setValidators(newValidator);\n    }\n    /**\n     * Sets the async validators that are active on this control. Calling this\n     * overwrites any existing async validators.\n     */\n    setAsyncValidators(newValidator) {\n        return super.setAsyncValidators(newValidator);\n    }\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```ts\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    setErrors(errors, opts = {}) {\n        return super.setErrors(errors, opts);\n    }\n    /**\n     * Reports error data for the current control.\n     *\n     * @param errorCode The code of the error to check.\n     *\n     * @returns error data for that particular error. If an error is not present,\n     * null is returned.\n     */\n    getError(errorCode) {\n        return super.getError(errorCode);\n    }\n    /**\n     * Reports whether the current control has the error specified.\n     *\n     * @param errorCode The code of the error to check.\n     *\n     * @returns whether the given error is present in the current control.\n     *\n     * If an error is not present, false is returned.\n     */\n    hasError(errorCode) {\n        return super.hasError(errorCode);\n    }\n}\n\nclass FormGroup extends FormGroup$1 {\n    /**\n     * Creates a new `FormGroup` instance.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     * @todo Chechout how to respect optional and require properties modifyers for the controls.\n     */\n    constructor(controls, validatorOrOpts, asyncValidator) {\n        super(controls, validatorOrOpts, asyncValidator);\n        this.controls = controls;\n    }\n    /**\n     * Registers a control with the group's list of controls.\n     *\n     * This method does not update the value or validity of the control.\n     * Use [addControl](https://angular.io/api/forms/FormGroup#addControl) instead.\n     *\n     * @param name The control name to register in the collection\n     * @param control Provides the control for the given name\n     */\n    registerControl(name, control) {\n        return super.registerControl(name, control);\n    }\n    /**\n     * Add a control to this group.\n     *\n     * This method also updates the value and validity of the control.\n     *\n     * @param name The control name to add to the collection\n     * @param control Provides the control for the given name\n     */\n    addControl(name, control) {\n        return super.addControl(name, control);\n    }\n    /**\n     * Remove a control from this group.\n     *\n     * @param name The control name to remove from the collection\n     */\n    removeControl(name) {\n        return super.removeControl(name);\n    }\n    /**\n     * Replace an existing control.\n     *\n     * @param name The control name to replace in the collection\n     * @param control Provides the control for the given name\n     */\n    setControl(name, control) {\n        return super.setControl(name, control);\n    }\n    /**\n     * Check whether there is an enabled control with the given name in the group.\n     *\n     * Reports false for disabled controls. If you'd like to check for existence in the group\n     * only, use [get](https://angular.io/api/forms/AbstractControl#get) instead.\n     *\n     * @param name The control name to check for existence in the collection\n     *\n     * @returns false for disabled controls, true otherwise.\n     */\n    contains(name) {\n        return super.contains(name);\n    }\n    /**\n     * Sets the value of the `FormGroup`. It accepts an object that matches\n     * the structure of the group, with control names as keys.\n     *\n     * ### Set the complete value for the form group\n     *\n  ```ts\n  const form = new FormGroup({\n    first: new FormControl(),\n    last: new FormControl()\n  });\n  \n  console.log(form.value);   // {first: null, last: null}\n  \n  form.setValue({first: 'Nancy', last: 'Drew'});\n  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n  ```\n     *\n     * @throws When strict checks fail, such as setting the value of a control\n     * that doesn't exist or if you excluding the value of a control.\n     *\n     * @param value The new value for the control that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     */\n    setValue(value, options = {}) {\n        return super.setValue(value, options);\n    }\n    /**\n     * Patches the value of the `FormGroup`. It accepts an object with control\n     * names as keys, and does its best to match the values to the correct controls\n     * in the group.\n     *\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\n     *\n     * ### Patch the value for a form group\n     *\n  ```ts\n  const form = new FormGroup({\n     first: new FormControl(),\n     last: new FormControl()\n  });\n  console.log(form.value);   // {first: null, last: null}\n  \n  form.patchValue({first: 'Nancy'});\n  console.log(form.value);   // {first: 'Nancy', last: null}\n  ```\n     *\n     * @param value The object that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes and\n     * emits events after the value is patched.\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n     * true.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    patchValue(value, options = {}) {\n        return super.patchValue(value, options);\n    }\n    /**\n     * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n     * the value of all descendants to null.\n     *\n     * You reset to a specific form state by passing in a map of states\n     * that matches the structure of your form, with control names as keys. The state\n     * is a standalone value or a form state object with both a value and a disabled\n     * status.\n     *\n     * @param formState Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the group is reset.\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     *\n     *\n     * ### Reset the form group values\n     *\n  ```ts\n  const form = new FormGroup({\n    first: new FormControl('first name'),\n    last: new FormControl('last name')\n  });\n  \n  console.log(form.value);  // {first: 'first name', last: 'last name'}\n  \n  form.reset({ first: 'name', last: 'last name' });\n  \n  console.log(form.value);  // {first: 'name', last: 'last name'}\n  ```\n     *\n     * ### Reset the form group values and disabled status\n     *\n  ```ts\n  const form = new FormGroup({\n    first: new FormControl('first name'),\n    last: new FormControl('last name')\n  });\n  \n  form.reset({\n    first: {value: 'name', disabled: true},\n    last: 'last'\n  });\n  \n  console.log(this.form.value);  // {first: 'name', last: 'last name'}\n  console.log(this.form.get('first').status);  // 'DISABLED'\n  ```\n     */\n    reset(value = {}, options = {}) {\n        return super.reset(value, options);\n    }\n    /**\n     * The aggregate value of the `FormGroup`, including any disabled controls.\n     *\n     * Retrieves all values regardless of disabled status.\n     * The `value` property is the best way to get the value of the group, because\n     * it excludes disabled controls in the `FormGroup`.\n     */\n    getRawValue() {\n        return super.getRawValue();\n    }\n    /**\n     * Retrieves a child control given the control's name.\n     *\n     * ### Retrieve a nested control\n     *\n     * For example, to get a `name` control nested within a `person` sub-group:\n  ```ts\n  this.form.get('person').get('name');\n  ```\n     */\n    get(controlName) {\n        return super.get(controlName);\n    }\n    /**\n     * Sets the synchronous validators that are active on this control. Calling\n     * this overwrites any existing sync validators.\n     */\n    setValidators(newValidator) {\n        return super.setValidators(newValidator);\n    }\n    /**\n     * Sets the async validators that are active on this control. Calling this\n     * overwrites any existing async validators.\n     */\n    setAsyncValidators(newValidator) {\n        return super.setAsyncValidators(newValidator);\n    }\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```ts\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    setErrors(errors, opts = {}) {\n        return super.setErrors(errors, opts);\n    }\n    /**\n     * Reports error data for the control with the given controlName.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n     *\n  ```ts\n  form.get('address').getError('someErrorCode', 'street');\n  ```\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode, controlName) {\n        return super.getError(errorCode, controlName);\n    }\n    /**\n     * Reports whether the control with the given controlName has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n  ```ts\n  form.get('address').hasError('someErrorCode', 'street');\n  ```\n     *\n     * If no controlName is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given controlName.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode, controlName) {\n        return super.hasError(errorCode, controlName);\n    }\n}\n\n// Next flag used because of this https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-373487183\n// @dynamic\n/**\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * See also [Form Validation](https://angular.io/guide/form-validation).\n */\nclass Validators extends Validators$1 {\n    /**\n     * Validator that requires the control's value to be greater than or equal to the provided number.\n     * The validator exists only as a function and not as a directive.\n     *\n     * ### Validate against a minimum of 3\n     *\n     * ```ts\n     * const control = new FormControl(2, Validators.min(3));\n     *\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `min` property if the validation check fails, otherwise `null`.\n     *\n     */\n    static min(min) {\n        return super.min(min);\n    }\n    /**\n     * Validator that requires the control's value to be less than or equal to the provided number.\n     * The validator exists only as a function and not as a directive.\n     *\n     * ### Validate against a maximum of 15\n     *\n     * ```ts\n     * const control = new FormControl(16, Validators.max(15));\n     *\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `max` property if the validation check fails, otherwise `null`.\n     *\n     */\n    static max(max) {\n        return super.max(max);\n    }\n    /**\n     * Validator that requires the control have a non-empty value.\n     *\n     * ### Validate that the field is non-empty\n     *\n     * ```ts\n     * const control = new FormControl('', Validators.required);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map with the `required` property\n     * if the validation check fails, otherwise `null`.\n     *\n     */\n    static required(control) {\n        return super.required(control);\n    }\n    /**\n     * Validator that requires the control's value be true. This validator is commonly\n     * used for required checkboxes.\n     *\n     * ### Validate that the field value is true\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.requiredTrue);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map that contains the `required` property\n     * set to `true` if the validation check fails, otherwise `null`.\n     */\n    static requiredTrue(control) {\n        return super.requiredTrue(control);\n    }\n    /**\n     * Validator that requires the control's value pass an email validation test.\n     *\n     * ### Validate that the field matches a valid email pattern\n     *\n     * ```typescript\n     * const control = new FormControl('bad@', Validators.email);\n     *\n     * console.log(control.errors); // {email: true}\n     * ```\n     *\n     * @returns An error map with the `email` property\n     * if the validation check fails, otherwise `null`.\n     *\n     */\n    static email(control) {\n        return super.email(control);\n    }\n    /**\n     * Validator that requires the length of the control's value to be greater than or equal\n     * to the provided minimum length. This validator is also provided by default if you use the\n     * the HTML5 `minlength` attribute.\n     *\n     * ### Validate that the field has a minimum of 3 characters\n     *\n     * ```typescript\n     * const control = new FormControl('ng', Validators.minLength(3));\n     *\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n     * ```\n     *\n     * ```html\n     * <input minlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `minlength` if the validation check fails, otherwise `null`.\n     */\n    static minLength(minLength) {\n        return super.minLength(minLength);\n    }\n    /**\n     * Validator that requires the length of the control's value to be less than or equal\n     * to the provided maximum length. This validator is also provided by default if you use the\n     * the HTML5 `maxlength` attribute.\n     *\n     * ### Validate that the field has maximum of 5 characters\n     *\n     * ```typescript\n     * const control = new FormControl('Angular', Validators.maxLength(5));\n     *\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n     * ```\n     *\n     * ```html\n     * <input maxlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `maxlength` property if the validation check fails, otherwise `null`.\n     */\n    static maxLength(maxLength) {\n        return super.maxLength(maxLength);\n    }\n    /**\n     * Validator that requires the control's value to match a regex pattern. This validator is also\n     * provided by default if you use the HTML5 `pattern` attribute.\n     *\n     * Note that if a Regexp is provided, the Regexp is used as is to test the values. On the other\n     * hand, if a string is passed, the `^` character is prepended and the `$` character is\n     * appended to the provided string (if not already present), and the resulting regular\n     * expression is used to test the values.\n     *\n     * ### Validate that the field only contains letters or spaces\n     *\n     * ```typescript\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n     *\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n     * ```\n     *\n     * ```html\n     * <input pattern=\"[a-zA-Z ]*\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `pattern` property if the validation check fails, otherwise `null`.\n     */\n    static pattern(pattern) {\n        return super.pattern(pattern);\n    }\n    /**\n     * Validator that performs no operation.\n     */\n    static nullValidator(control) {\n        return null;\n    }\n    static compose(validators) {\n        return super.compose(validators);\n    }\n    /**\n     * Compose multiple async validators into a single function that returns the union\n     * of the individual error objects for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\n     */\n    static composeAsync(validators) {\n        return super.composeAsync(validators);\n    }\n    /**\n     * At least one file should be.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    static fileRequired(formControl) {\n        if (!(formControl.value instanceof FormData)) {\n            return { fileRequired: true };\n        }\n        const files = [];\n        formControl.value.forEach((file) => files.push(file));\n        for (const file of files) {\n            if (file instanceof File) {\n                return null;\n            }\n        }\n        return { fileRequired: true };\n    }\n    /**\n     * Minimal number of files.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    static filesMinLength(minLength) {\n        return (formControl) => {\n            const value = formControl.value;\n            if (minLength < 1) {\n                return null;\n            }\n            if (!value || !(value instanceof FormData)) {\n                return { filesMinLength: { requiredLength: minLength, actualLength: 0 } };\n            }\n            const files = [];\n            value.forEach((file) => files.push(file));\n            const len = files.length;\n            if (len < minLength) {\n                return { filesMinLength: { requiredLength: minLength, actualLength: len } };\n            }\n            return null;\n        };\n    }\n    /**\n     * Maximal number of files.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    static filesMaxLength(maxLength) {\n        return (formControl) => {\n            if (!(formControl.value instanceof FormData)) {\n                return null;\n            }\n            const files = [];\n            formControl.value.forEach((file) => files.push(file));\n            const len = files.length;\n            if (len > maxLength) {\n                return { filesMaxLength: { requiredLength: maxLength, actualLength: len } };\n            }\n            return null;\n        };\n    }\n    /**\n     * Maximal size of a file.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    static fileMaxSize(maxSize) {\n        return (formControl) => {\n            if (!(formControl.value instanceof FormData)) {\n                return null;\n            }\n            const files = [];\n            formControl.value.forEach((file) => files.push(file));\n            for (const file of files) {\n                if (file instanceof File && file.size > maxSize) {\n                    return { fileMaxSize: { requiredSize: maxSize, actualSize: file.size, file } };\n                }\n            }\n            return null;\n        };\n    }\n}\n\nconst sym = Symbol();\n/**\n * The default validators model, it includes almost all properties of `typeof Validators`,\n * excludes: `prototype`, `compose`, `composeAsync` and `nullValidator`.\n *\n * ### Usage\n *\n```ts\nconst formControl = new FormControl<string, ValidatorsModel>('some value');\n// OR\nconst formGroup = new FormGroup<any, ValidatorsModel>({});\n// OR\nconst formArray = new FormArray<any, ValidatorsModel>([]);\n```\n */\nclass ValidatorsModel {\n}\n\n/*\n * Public API Surface of forms\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FormArray, FormBuilder, FormControl, FormGroup, InputFileDirective, NgStackFormsModule, Validators, ValidatorsModel };\n//# sourceMappingURL=ng-stack-forms.js.map\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./input-validation\";\nvar styles_InputValidationComponent = [];\nvar RenderType_InputValidationComponent = i0.ɵcrt({ encapsulation: 2, styles: styles_InputValidationComponent, data: {} });\nexport { RenderType_InputValidationComponent as RenderType_InputValidationComponent };\nfunction View_InputValidationComponent_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, null, null, null, null, null, null, null)), (_l()(), i0.ɵeld(1, 0, null, null, 1, \"span\", [[\"class\", \"text-danger\"]], null, null, null, null, null)), (_l()(), i0.ɵted(2, null, [\"\", \"\"]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.errorMsgs[_v.context.$implicit]; _ck(_v, 2, 0, currVal_0); }); }\nfunction View_InputValidationComponent_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"div\", [], null, null, null, null, null)), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_InputValidationComponent_2)), i0.ɵdid(2, 278528, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.ObjectKeys(_co.control.errors); _ck(_v, 2, 0, currVal_0); }, null); }\nexport function View_InputValidationComponent_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵand(16777216, null, null, 1, null, View_InputValidationComponent_1)), i0.ɵdid(1, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.errorValidation(_co.control); _ck(_v, 1, 0, currVal_0); }, null); }\nexport function View_InputValidationComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"app-input-validation\", [], null, null, null, View_InputValidationComponent_0, RenderType_InputValidationComponent)), i0.ɵdid(1, 49152, null, 0, i2.InputValidationComponent, [], null, null)], null, null); }\nvar InputValidationComponentNgFactory = i0.ɵccf(\"app-input-validation\", i2.InputValidationComponent, View_InputValidationComponent_Host_0, { control: \"control\", errorMsgs: \"errorMsgs\", errorValidation: \"errorValidation\" }, {}, []);\nexport { InputValidationComponentNgFactory as InputValidationComponentNgFactory };\n","<div *ngIf=\"errorValidation(control)\">\r\n    <ng-container *ngFor=\"let error of ObjectKeys(control.errors); let first = first\">\r\n        <span class=\"text-danger\">{{ errorMsgs[error] }}</span>\r\n    </ng-container>\r\n</div>","import { Component, Input } from '@angular/core';\r\nimport { FormControl, FormGroup } from '@ng-stack/forms';\r\nimport { FormUtil } from '@shared/validators/form.utils';\r\n\r\n\r\n@Component({\r\n  selector: 'app-input-validation',\r\n  templateUrl: \"./input-validation.html\",\r\n})\r\nexport class InputValidationComponent {\r\n    @Input() control: FormControl | FormGroup;\r\n    @Input() errorMsgs = {};\r\n    @Input() errorValidation = FormUtil.errorValidation;\r\n  \r\n    ObjectKeys = Object.keys;\r\n}\r\n","import { Directive, ElementRef, HostListener, Input } from '@angular/core';\r\nimport { NgControl } from '@angular/forms';\r\n\r\n@Directive({\r\n  selector: 'input[numbersOnly]'\r\n})\r\nexport class NumberDirective {\r\n\r\n  constructor(private _el: ElementRef) { }\r\n\r\n  @HostListener('input', ['$event']) onInputChange(event) {\r\n    const initalValue = this._el.nativeElement.value;\r\n    this._el.nativeElement.value = initalValue.replace(/[^0-9]*/g, '');\r\n    if ( initalValue !== this._el.nativeElement.value) {\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n}\r\n","import { AbstractControl } from '@angular/forms';\r\nimport { FormGroup, Validators } from '@ng-stack/forms';\r\n\r\n\r\nexport class FormUtil {\r\n\r\n  static errorValidation(formControl: AbstractControl) {\r\n    return formControl.invalid && formControl.touched;\r\n  }\r\n\r\n  static errorValidationDirty(formControl: AbstractControl) {\r\n    return formControl.invalid && formControl.touched && formControl.dirty;\r\n  }\r\n\r\n  static emptyOrNull(formControl: AbstractControl) {\r\n    return formControl.value === null || formControl.value === '';\r\n  }\r\n\r\n  static touchForm(form: FormGroup) {\r\n    form.markAsTouched();\r\n    Object.keys(form.controls).forEach(control => form.controls[control].markAsTouched());\r\n  }\r\n\r\n  static dirtyForm(form: FormGroup) {\r\n    form.markAsDirty();\r\n    Object.keys(form.controls).forEach(control => form.controls[control].markAsDirty());\r\n  }\r\n\r\n  static updateValidationInput(input: AbstractControl) {\r\n    input.updateValueAndValidity();\r\n    input.markAsDirty();\r\n    input.markAsTouched();\r\n  }\r\n\r\n  static requiredEnabled(control: AbstractControl) {\r\n    control.setValidators([ Validators.required ]);\r\n    control.enable();\r\n  }\r\n\r\n  static notRequiredEnabled(control: AbstractControl) {\r\n    control.clearValidators();\r\n    control.enable();\r\n  }\r\n\r\n  static notRequiredDisabled(control: AbstractControl) {\r\n    control.clearValidators();\r\n    control.disable();\r\n  }\r\n\r\n  static isoDateStringToBrDateString(isoDate: string) {\r\n    if (!isoDate || isoDate === '') {\r\n      return '';\r\n    }\r\n\r\n    const dateMs = Date.parse(isoDate);\r\n    const date = new Date(dateMs);\r\n\r\n    return (\r\n      date.getUTCDate().toString().padStart(2, '0') + '/' +\r\n      (date.getUTCMonth() + 1).toString().padStart(2, '0') + '/' +\r\n      date.getUTCFullYear().toString()\r\n    );\r\n  }\r\n\r\n  static brDateStringToIsoDateString(brDate: string) {\r\n    const date = brDate.split('/');\r\n\r\n    return date[2] + '-' + date[1] + '-' + date[0];\r\n  }\r\n\r\n  static validateForm(form: FormGroup) {\r\n    FormUtil.touchForm(form);\r\n    FormUtil.dirtyForm(form);\r\n\r\n    return form.valid;\r\n  }\r\n\r\n  static resetValueAndValidators(control: AbstractControl) {\r\n    control.reset();\r\n    control.clearValidators();\r\n    control.updateValueAndValidity();\r\n  }\r\n}\r\n"],"sourceRoot":""}