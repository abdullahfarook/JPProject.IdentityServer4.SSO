{"version":3,"sources":["./node_modules/@ng-stack/forms/fesm5/ng-stack-forms.js","./src/app/shared/components/input-validation/input-validation.html","./src/app/shared/components/input-validation/input-validation.ts","./src/app/shared/directives/numberCheck/numbers-only.directive.ts","./src/app/shared/validators/form.utils.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoE;AAC0E;AACsE;;AAEpN;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B,UAAU,gDAAgD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B,QAAQ,gEAAU;AAClB;AACA;AACA,CAAC,CAAC,0DAAa;;AAEf;AACA;AACA;AACA;AACA,0BAA0B,0DAAY;AACtC,0CAA0C;AAC1C,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAA6C,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,SAAS,OAAO,wDAAU,EAAE;AAC5B,SAAS,OAAO,uDAAS;AACzB,MAAM;AACN,IAAI,wDAAU;AACd,QAAQ,2DAAK;AACb,QAAQ,wDAAU;AAClB;AACA,IAAI,wDAAU;AACd,QAAQ,4DAAM;AACd,QAAQ,wDAAU;AAClB;AACA,IAAI,wDAAU;AACd,QAAQ,kEAAY;AACpB,QAAQ,wDAAU;AAClB,QAAQ,wDAAU;AAClB,QAAQ,wDAAU;AAClB;AACA,gDAAgD,wDAAU;AAC1D,QAAQ,+DAAS;AACjB;AACA,yBAAyB,UAAU,gEAAiB,eAAe,gEAAU,cAAc,6BAA6B,EAAE,gBAAgB;AAC1I,SAAS;AACT,QAAQ,wDAAU,uBAAuB,wDAAU,EAAE,uDAAS;AAC9D;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,yBAAyB,wDAAU;AACnC,QAAQ,8DAAQ;AAChB;AACA,sBAAsB,kEAAmB;AACzC;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8BAA8B;AACnC;AACA;;AAEA,8BAA8B;AAC9B,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,wDAAW;;AAEb;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,0DAAa;;AAEf;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,0BAA0B,OAAO;;AAEjC,iBAAiB,6BAA6B;AAC9C,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,0BAA0B,OAAO;;AAEjC,mBAAmB,eAAe;AAClC,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,0BAA0B,MAAM;;AAEhC,cAAc,mCAAmC;;AAEjD,0BAA0B,MAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,YAAY,8BAA8B;AAC1C;AACA,GAAG;;AAEH,+BAA+B,MAAM;AACrC,6CAA6C;AAC7C;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,wDAAW;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK,MAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK,MAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,mDAAmD,yBAAyB,EAAE;AAC9E;AACA,+BAA+B,sDAAQ,oCAAoC,iBAAiB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB,6CAA6C;AACvF;AACA;AACA,2CAA2C,yBAAyB,EAAE;AACtE;AACA;AACA,wBAAwB,kBAAkB,+CAA+C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB,EAAE;AAClF;AACA;AACA,wBAAwB,kBAAkB,+CAA+C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB,EAAE;AAClF;AACA,mCAAmC,sDAAQ,oCAAoC,iBAAiB;AAChG;AACA;AACA,gCAAgC,eAAe,2DAA2D;AAC1G;AACA;AACA;AACA,2BAA2B,QAAQ,gBAAgB;AACnD;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,yDAAY;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAE+H;AAC/H;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8GCvxCI,wHAAkF,KAC9E,gJAA0B,qNAAsB;8GAFxD,uHAAsC,KAClC,0dAAkF,iDAApE,kCAAmE,kBAAjF,YAAkF,EAApE,SAAmE;8GADrF,iZAAsC,iDAAjC,uCAAgC,WAArC,YAAsC,EAAjC,SAAgC;;;;;;;;;;;;;;;;AC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","file":"8-es5.7c58d1fb1c6b788baae3.js","sourcesContent":["import { __extends, __decorate, __metadata, __values } from 'tslib';\nimport { Injectable, EventEmitter, ElementRef, Renderer2, Input, Output, HostListener, Directive, forwardRef, NgModule } from '@angular/core';\nimport { FormBuilder as FormBuilder$1, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormArray as FormArray$1, FormControl as FormControl$1, FormGroup as FormGroup$1, Validators as Validators$1 } from '@angular/forms';\n\nvar FormBuilder = /** @class */ (function (_super) {\n    __extends(FormBuilder, _super);\n    function FormBuilder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Construct a new `FormGroup` instance.\n     *\n     * @param controlsConfig A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param options Configuration options object for the `FormGroup`. The object can\n     * have two shapes:\n     *\n     * 1) `AbstractControlOptions` object (preferred), which consists of:\n     * - `validators`: A synchronous validator function, or an array of validator functions\n     * - `asyncValidators`: A single async validator or array of async validator functions\n     * - `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur' |\n     * submit')\n     *\n     * 2) Legacy configuration object, which consists of:\n     * - `validator`: A synchronous validator function, or an array of validator functions\n     * - `asyncValidator`: A single async validator or array of async validator functions\n     */\n    FormBuilder.prototype.group = function (controlsConfig, options) {\n        if (options === void 0) { options = null; }\n        return _super.prototype.group.call(this, controlsConfig, options);\n    };\n    /**\n     * @description\n     * Construct a new `FormControl` with the given state, validators and options.\n     *\n     * @param formState Initializes the control with an initial state value, or\n     * with an object that contains both a value and a disabled status.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator\n     * functions.\n     *\n     * ### Initialize a control as disabled\n     *\n     * The following example returns a control with an initial value in a disabled state.\n  ```ts\n  import {Component, Inject} from '@angular/core';\n  import {FormBuilder, FormControl, FormGroup, Validators} from '@angular/forms';\n  // ...\n  @Component({\n    selector: 'app-disabled-form-control',\n    template: `\n      <input [formControl]=\"control\" placeholder=\"First\">\n    `\n  })\n  export class DisabledFormControlComponent {\n    control: FormControl;\n  \n    constructor(private fb: FormBuilder) {\n      this.control = fb.control({value: 'my val', disabled: true});\n    }\n  }\n  ```\n     */\n    FormBuilder.prototype.control = function (formState, validatorOrOpts, asyncValidator) {\n        if (formState === void 0) { formState = null; }\n        return _super.prototype.control.call(this, formState, validatorOrOpts, asyncValidator);\n    };\n    /**\n     * Constructs a new `FormArray` from the given array of configurations,\n     * validators and options.\n     *\n     * @param controlsConfig An array of child controls or control configs. Each\n     * child control is given an index when it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains\n     * validation functions and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator\n     * functions.\n     */\n    FormBuilder.prototype.array = function (controlsConfig, validatorOrOpts, asyncValidator) {\n        return _super.prototype.array.call(this, controlsConfig, validatorOrOpts, asyncValidator);\n    };\n    FormBuilder = __decorate([\n        Injectable()\n    ], FormBuilder);\n    return FormBuilder;\n}(FormBuilder$1));\n\nvar InputFileDirective = /** @class */ (function () {\n    function InputFileDirective(elementRef, renderer) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.select = new EventEmitter();\n        this.onChange = function (value) { };\n        this.onTouched = function () { };\n    }\n    InputFileDirective_1 = InputFileDirective;\n    /**\n     * Callback function that should be called when\n     * the control's value changes in the UI.\n     */\n    InputFileDirective.prototype.callOnChange = function (event) {\n        this.onTouched();\n        var files = Array.from(this.elementRef.nativeElement.files);\n        var formData = new FormData();\n        var formInputName = this.elementRef.nativeElement.name || 'uploadFile';\n        if (this.multiple !== undefined && this.multiple !== false && this.multiple !== 'false') {\n            formInputName += '[]';\n        }\n        files.forEach(function (file) { return formData.append(formInputName, file); });\n        this.onChange(formData);\n        this.select.next(files);\n        event.target.value = null;\n    };\n    /**\n     * Writes a new value to the element.\n     * This method will be called by the forms API to write\n     * to the view when programmatic (model -> view) changes are requested.\n     *\n     * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)\n     */\n    InputFileDirective.prototype.writeValue = function (fileList) {\n        if (fileList && !(fileList instanceof FileList)) {\n            throw new TypeError('Value for input[type=file] must be an instance of FileList');\n        }\n        this.renderer.setProperty(this.elementRef.nativeElement, 'files', fileList);\n    };\n    /**\n     * Registers a callback function that should be called when\n     * the control's value changes in the UI.\n     *\n     * This is called by the forms API on initialization so it can update\n     * the form model when values propagate from the view (view -> model).\n     */\n    InputFileDirective.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * Registers a callback function that should be called when the control receives a change event.\n     * This is called by the forms API on initialization so it can update the form model on change.\n     */\n    InputFileDirective.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    var InputFileDirective_1;\n    InputFileDirective.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Renderer2 }\n    ]; };\n    __decorate([\n        Input(),\n        __metadata(\"design:type\", Object)\n    ], InputFileDirective.prototype, \"multiple\", void 0);\n    __decorate([\n        Output(),\n        __metadata(\"design:type\", Object)\n    ], InputFileDirective.prototype, \"select\", void 0);\n    __decorate([\n        HostListener('change', ['$event']),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [Object]),\n        __metadata(\"design:returntype\", void 0)\n    ], InputFileDirective.prototype, \"callOnChange\", null);\n    InputFileDirective = InputFileDirective_1 = __decorate([\n        Directive({\n            selector: \"\\n  input[type=file][ngModel],\\n  input[type=file][formControl],\\n  input[type=file][formControlName]\",\n            providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return InputFileDirective_1; }), multi: true }],\n        }),\n        __metadata(\"design:paramtypes\", [ElementRef, Renderer2])\n    ], InputFileDirective);\n    return InputFileDirective;\n}());\n\nvar NgStackFormsModule = /** @class */ (function () {\n    function NgStackFormsModule() {\n    }\n    NgStackFormsModule = __decorate([\n        NgModule({\n            declarations: [InputFileDirective],\n            exports: [ReactiveFormsModule, InputFileDirective],\n            providers: [FormBuilder],\n        })\n    ], NgStackFormsModule);\n    return NgStackFormsModule;\n}());\n\nvar FormArray = /** @class */ (function (_super) {\n    __extends(FormArray, _super);\n    /**\n     * Creates a new `FormArray` instance.\n     *\n     * @param controls An array of child controls. Each child control is given an index\n     * where it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    function FormArray(controls, validatorOrOpts, asyncValidator) {\n        var _this = _super.call(this, controls, validatorOrOpts, asyncValidator) || this;\n        _this.controls = controls;\n        return _this;\n    }\n    /**\n     * Get the Control at the given `index` in the array.\n     *\n     * @param index Index in the array to retrieve the control\n     */\n    FormArray.prototype.at = function (index) {\n        return _super.prototype.at.call(this, index);\n    };\n    /**\n     * Insert a new Control at the end of the array.\n     *\n     * @param control Form control to be inserted\n     */\n    FormArray.prototype.push = function (control) {\n        return _super.prototype.push.call(this, control);\n    };\n    /**\n     * Insert a new Control at the given `index` in the array.\n     *\n     * @param index Index in the array to insert the control\n     * @param control Form control to be inserted\n     */\n    FormArray.prototype.insert = function (index, control) {\n        return _super.prototype.insert.call(this, index, control);\n    };\n    /**\n     * Replace an existing control.\n     *\n     * @param index Index in the array to replace the control\n     * @param control The Control control to replace the existing control\n     */\n    FormArray.prototype.setControl = function (index, control) {\n        return _super.prototype.setControl.call(this, index, control);\n    };\n    /**\n     * Sets the value of the `FormArray`. It accepts an array that matches\n     * the structure of the control.\n     *\n     * This method performs strict checks, and throws an error if you try\n     * to set the value of a control that doesn't exist or if you exclude the\n     * value of a control.\n     *\n     * ### Set the values for the controls in the form array\n     *\n  ```ts\n  const arr = new FormArray([\n    new FormControl(),\n    new FormControl()\n  ]);\n  console.log(arr.value);   // [null, null]\n  \n  arr.setValue(['Nancy', 'Drew']);\n  console.log(arr.value);   // ['Nancy', 'Drew']\n  ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    FormArray.prototype.setValue = function (value, options) {\n        if (options === void 0) { options = {}; }\n        return _super.prototype.setValue.call(this, value, options);\n    };\n    /**\n     * Patches the value of the `FormArray`. It accepts an array that matches the\n     * structure of the control, and does its best to match the values to the correct\n     * controls in the group.\n     *\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\n     *\n     * ### Patch the values for controls in a form array\n     *\n  ```ts\n  const arr = new FormArray([\n     new FormControl(),\n     new FormControl()\n  ]);\n  console.log(arr.value);   // [null, null]\n  \n  arr.patchValue(['Nancy']);\n  console.log(arr.value);   // ['Nancy', null]\n  ```\n     *\n     * @param value Array of latest values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    FormArray.prototype.patchValue = function (value, options) {\n        if (options === void 0) { options = {}; }\n        return _super.prototype.patchValue.call(this, value, options);\n    };\n    /**\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n     * value of all descendants to null or null maps.\n     *\n     * You reset to a specific form state by passing in an array of states\n     * that matches the structure of the control. The state is a standalone value\n     * or a form state object with both a value and a disabled status.\n     *\n     * ### Reset the values in a form array\n     *\n  ```ts\n  const arr = new FormArray([\n     new FormControl(),\n     new FormControl()\n  ]);\n  arr.reset(['name', 'last name']);\n  \n  console.log(this.arr.value);  // ['name', 'last name']\n  ```\n     *\n     * ### Reset the values in a form array and the disabled status for the first control\n     *\n  ```\n  this.arr.reset([\n    {value: 'name', disabled: true},\n    'last'\n  ]);\n  \n  console.log(this.arr.value);  // ['name', 'last name']\n  console.log(this.arr.get(0).status);  // 'DISABLED'\n  ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    FormArray.prototype.reset = function (value, options) {\n        if (value === void 0) { value = []; }\n        if (options === void 0) { options = {}; }\n        return _super.prototype.reset.call(this, value, options);\n    };\n    /**\n     * The aggregate value of the array, including any disabled controls.\n     *\n     * Reports all values regardless of disabled status.\n     * For enabled controls only, the `value` property is the best way to get the value of the array.\n     */\n    FormArray.prototype.getRawValue = function () {\n        return _super.prototype.getRawValue.call(this);\n    };\n    /**\n     * Sets the synchronous validators that are active on this control. Calling\n     * this overwrites any existing sync validators.\n     */\n    FormArray.prototype.setValidators = function (newValidator) {\n        return _super.prototype.setValidators.call(this, newValidator);\n    };\n    /**\n     * Sets the async validators that are active on this control. Calling this\n     * overwrites any existing async validators.\n     */\n    FormArray.prototype.setAsyncValidators = function (newValidator) {\n        return _super.prototype.setAsyncValidators.call(this, newValidator);\n    };\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```ts\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    FormArray.prototype.setErrors = function (errors, opts) {\n        if (opts === void 0) { opts = {}; }\n        return _super.prototype.setErrors.call(this, errors, opts);\n    };\n    /**\n     * Reports error data for the control with the given controlName.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n     *\n  ```ts\n  form.get('address').getError('someErrorCode', 'street');\n  ```\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    FormArray.prototype.getError = function (errorCode, controlName) {\n        return _super.prototype.getError.call(this, errorCode, controlName);\n    };\n    /**\n     * Reports whether the control with the given controlName has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n  ```ts\n  form.get('address').hasError('someErrorCode', 'street');\n  ```\n     *\n     * If no controlName is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given controlName.\n     *\n     * If the control is not present, false is returned.\n     */\n    FormArray.prototype.hasError = function (errorCode, controlName) {\n        return _super.prototype.hasError.call(this, errorCode, controlName);\n    };\n    return FormArray;\n}(FormArray$1));\n\nvar FormControl = /** @class */ (function (_super) {\n    __extends(FormControl, _super);\n    /**\n     * Creates a new `FormControl` instance.\n     *\n     * @param formState Initializes the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    function FormControl(formState, validatorOrOpts, asyncValidator) {\n        if (formState === void 0) { formState = null; }\n        return _super.call(this, formState, validatorOrOpts, asyncValidator) || this;\n    }\n    /**\n     * Sets a new value for the form control.\n     *\n     * @param value The new value for the control.\n     * @param options Configuration options that determine how the control proopagates changes\n     * and emits events when the value changes.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n     * `onChange` event to\n     * update the view.\n     * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n     * `ngModelChange`\n     * event to update the model.\n     *\n     */\n    FormControl.prototype.setValue = function (value, options) {\n        if (options === void 0) { options = {}; }\n        return _super.prototype.setValue.call(this, value, options);\n    };\n    /**\n     * Patches the value of a control.\n     *\n     * This function is functionally the same as [setValue](https://angular.io/api/forms/FormControl#setValue) at this level.\n     * It exists for symmetry with [patchValue](https://angular.io/api/forms/FormGroup#patchValue) on `FormGroups` and\n     * `FormArrays`, where it does behave differently.\n     *\n     * See also: `setValue` for options\n     */\n    FormControl.prototype.patchValue = function (value, options) {\n        if (options === void 0) { options = {}; }\n        return _super.prototype.patchValue.call(this, value, options);\n    };\n    /**\n     * Resets the form control, marking it `pristine` and `untouched`, and setting\n     * the value to null.\n     *\n     * @param formState Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     *\n     */\n    FormControl.prototype.reset = function (formState, options) {\n        if (formState === void 0) { formState = null; }\n        if (options === void 0) { options = {}; }\n        return _super.prototype.reset.call(this, formState, options);\n    };\n    /**\n     * In `FormControl`, this method always returns `null`.\n     */\n    FormControl.prototype.get = function () {\n        return null;\n    };\n    /**\n     * Sets the synchronous validators that are active on this control. Calling\n     * this overwrites any existing sync validators.\n     */\n    FormControl.prototype.setValidators = function (newValidator) {\n        return _super.prototype.setValidators.call(this, newValidator);\n    };\n    /**\n     * Sets the async validators that are active on this control. Calling this\n     * overwrites any existing async validators.\n     */\n    FormControl.prototype.setAsyncValidators = function (newValidator) {\n        return _super.prototype.setAsyncValidators.call(this, newValidator);\n    };\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```ts\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    FormControl.prototype.setErrors = function (errors, opts) {\n        if (opts === void 0) { opts = {}; }\n        return _super.prototype.setErrors.call(this, errors, opts);\n    };\n    /**\n     * Reports error data for the current control.\n     *\n     * @param errorCode The code of the error to check.\n     *\n     * @returns error data for that particular error. If an error is not present,\n     * null is returned.\n     */\n    FormControl.prototype.getError = function (errorCode) {\n        return _super.prototype.getError.call(this, errorCode);\n    };\n    /**\n     * Reports whether the current control has the error specified.\n     *\n     * @param errorCode The code of the error to check.\n     *\n     * @returns whether the given error is present in the current control.\n     *\n     * If an error is not present, false is returned.\n     */\n    FormControl.prototype.hasError = function (errorCode) {\n        return _super.prototype.hasError.call(this, errorCode);\n    };\n    return FormControl;\n}(FormControl$1));\n\nvar FormGroup = /** @class */ (function (_super) {\n    __extends(FormGroup, _super);\n    /**\n     * Creates a new `FormGroup` instance.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     * @todo Chechout how to respect optional and require properties modifyers for the controls.\n     */\n    function FormGroup(controls, validatorOrOpts, asyncValidator) {\n        var _this = _super.call(this, controls, validatorOrOpts, asyncValidator) || this;\n        _this.controls = controls;\n        return _this;\n    }\n    /**\n     * Registers a control with the group's list of controls.\n     *\n     * This method does not update the value or validity of the control.\n     * Use [addControl](https://angular.io/api/forms/FormGroup#addControl) instead.\n     *\n     * @param name The control name to register in the collection\n     * @param control Provides the control for the given name\n     */\n    FormGroup.prototype.registerControl = function (name, control) {\n        return _super.prototype.registerControl.call(this, name, control);\n    };\n    /**\n     * Add a control to this group.\n     *\n     * This method also updates the value and validity of the control.\n     *\n     * @param name The control name to add to the collection\n     * @param control Provides the control for the given name\n     */\n    FormGroup.prototype.addControl = function (name, control) {\n        return _super.prototype.addControl.call(this, name, control);\n    };\n    /**\n     * Remove a control from this group.\n     *\n     * @param name The control name to remove from the collection\n     */\n    FormGroup.prototype.removeControl = function (name) {\n        return _super.prototype.removeControl.call(this, name);\n    };\n    /**\n     * Replace an existing control.\n     *\n     * @param name The control name to replace in the collection\n     * @param control Provides the control for the given name\n     */\n    FormGroup.prototype.setControl = function (name, control) {\n        return _super.prototype.setControl.call(this, name, control);\n    };\n    /**\n     * Check whether there is an enabled control with the given name in the group.\n     *\n     * Reports false for disabled controls. If you'd like to check for existence in the group\n     * only, use [get](https://angular.io/api/forms/AbstractControl#get) instead.\n     *\n     * @param name The control name to check for existence in the collection\n     *\n     * @returns false for disabled controls, true otherwise.\n     */\n    FormGroup.prototype.contains = function (name) {\n        return _super.prototype.contains.call(this, name);\n    };\n    /**\n     * Sets the value of the `FormGroup`. It accepts an object that matches\n     * the structure of the group, with control names as keys.\n     *\n     * ### Set the complete value for the form group\n     *\n  ```ts\n  const form = new FormGroup({\n    first: new FormControl(),\n    last: new FormControl()\n  });\n  \n  console.log(form.value);   // {first: null, last: null}\n  \n  form.setValue({first: 'Nancy', last: 'Drew'});\n  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n  ```\n     *\n     * @throws When strict checks fail, such as setting the value of a control\n     * that doesn't exist or if you excluding the value of a control.\n     *\n     * @param value The new value for the control that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     */\n    FormGroup.prototype.setValue = function (value, options) {\n        if (options === void 0) { options = {}; }\n        return _super.prototype.setValue.call(this, value, options);\n    };\n    /**\n     * Patches the value of the `FormGroup`. It accepts an object with control\n     * names as keys, and does its best to match the values to the correct controls\n     * in the group.\n     *\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\n     *\n     * ### Patch the value for a form group\n     *\n  ```ts\n  const form = new FormGroup({\n     first: new FormControl(),\n     last: new FormControl()\n  });\n  console.log(form.value);   // {first: null, last: null}\n  \n  form.patchValue({first: 'Nancy'});\n  console.log(form.value);   // {first: 'Nancy', last: null}\n  ```\n     *\n     * @param value The object that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes and\n     * emits events after the value is patched.\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n     * true.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     */\n    FormGroup.prototype.patchValue = function (value, options) {\n        if (options === void 0) { options = {}; }\n        return _super.prototype.patchValue.call(this, value, options);\n    };\n    /**\n     * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n     * the value of all descendants to null.\n     *\n     * You reset to a specific form state by passing in a map of states\n     * that matches the structure of your form, with control names as keys. The state\n     * is a standalone value or a form state object with both a value and a disabled\n     * status.\n     *\n     * @param formState Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the group is reset.\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the\n     * [updateValueAndValidity](https://angular.io/api/forms/AbstractControl#updateValueAndValidity) method.\n     *\n     *\n     * ### Reset the form group values\n     *\n  ```ts\n  const form = new FormGroup({\n    first: new FormControl('first name'),\n    last: new FormControl('last name')\n  });\n  \n  console.log(form.value);  // {first: 'first name', last: 'last name'}\n  \n  form.reset({ first: 'name', last: 'last name' });\n  \n  console.log(form.value);  // {first: 'name', last: 'last name'}\n  ```\n     *\n     * ### Reset the form group values and disabled status\n     *\n  ```ts\n  const form = new FormGroup({\n    first: new FormControl('first name'),\n    last: new FormControl('last name')\n  });\n  \n  form.reset({\n    first: {value: 'name', disabled: true},\n    last: 'last'\n  });\n  \n  console.log(this.form.value);  // {first: 'name', last: 'last name'}\n  console.log(this.form.get('first').status);  // 'DISABLED'\n  ```\n     */\n    FormGroup.prototype.reset = function (value, options) {\n        if (value === void 0) { value = {}; }\n        if (options === void 0) { options = {}; }\n        return _super.prototype.reset.call(this, value, options);\n    };\n    /**\n     * The aggregate value of the `FormGroup`, including any disabled controls.\n     *\n     * Retrieves all values regardless of disabled status.\n     * The `value` property is the best way to get the value of the group, because\n     * it excludes disabled controls in the `FormGroup`.\n     */\n    FormGroup.prototype.getRawValue = function () {\n        return _super.prototype.getRawValue.call(this);\n    };\n    /**\n     * Retrieves a child control given the control's name.\n     *\n     * ### Retrieve a nested control\n     *\n     * For example, to get a `name` control nested within a `person` sub-group:\n  ```ts\n  this.form.get('person').get('name');\n  ```\n     */\n    FormGroup.prototype.get = function (controlName) {\n        return _super.prototype.get.call(this, controlName);\n    };\n    /**\n     * Sets the synchronous validators that are active on this control. Calling\n     * this overwrites any existing sync validators.\n     */\n    FormGroup.prototype.setValidators = function (newValidator) {\n        return _super.prototype.setValidators.call(this, newValidator);\n    };\n    /**\n     * Sets the async validators that are active on this control. Calling this\n     * overwrites any existing async validators.\n     */\n    FormGroup.prototype.setAsyncValidators = function (newValidator) {\n        return _super.prototype.setAsyncValidators.call(this, newValidator);\n    };\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```ts\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    FormGroup.prototype.setErrors = function (errors, opts) {\n        if (opts === void 0) { opts = {}; }\n        return _super.prototype.setErrors.call(this, errors, opts);\n    };\n    /**\n     * Reports error data for the control with the given controlName.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n     *\n  ```ts\n  form.get('address').getError('someErrorCode', 'street');\n  ```\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    FormGroup.prototype.getError = function (errorCode, controlName) {\n        return _super.prototype.getError.call(this, errorCode, controlName);\n    };\n    /**\n     * Reports whether the control with the given controlName has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param controlName A control name that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * For example, for the following `FormGroup`:\n     *\n  ```ts\n  form = new FormGroup({\n    address: new FormGroup({ street: new FormControl() })\n  });\n  ```\n     *\n     * The controlName to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in combination with `get()` method:\n  ```ts\n  form.get('address').hasError('someErrorCode', 'street');\n  ```\n     *\n     * If no controlName is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given controlName.\n     *\n     * If the control is not present, false is returned.\n     */\n    FormGroup.prototype.hasError = function (errorCode, controlName) {\n        return _super.prototype.hasError.call(this, errorCode, controlName);\n    };\n    return FormGroup;\n}(FormGroup$1));\n\n// Next flag used because of this https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-373487183\n// @dynamic\n/**\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * See also [Form Validation](https://angular.io/guide/form-validation).\n */\nvar Validators = /** @class */ (function (_super) {\n    __extends(Validators, _super);\n    function Validators() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Validator that requires the control's value to be greater than or equal to the provided number.\n     * The validator exists only as a function and not as a directive.\n     *\n     * ### Validate against a minimum of 3\n     *\n     * ```ts\n     * const control = new FormControl(2, Validators.min(3));\n     *\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `min` property if the validation check fails, otherwise `null`.\n     *\n     */\n    Validators.min = function (min) {\n        return _super.min.call(this, min);\n    };\n    /**\n     * Validator that requires the control's value to be less than or equal to the provided number.\n     * The validator exists only as a function and not as a directive.\n     *\n     * ### Validate against a maximum of 15\n     *\n     * ```ts\n     * const control = new FormControl(16, Validators.max(15));\n     *\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `max` property if the validation check fails, otherwise `null`.\n     *\n     */\n    Validators.max = function (max) {\n        return _super.max.call(this, max);\n    };\n    /**\n     * Validator that requires the control have a non-empty value.\n     *\n     * ### Validate that the field is non-empty\n     *\n     * ```ts\n     * const control = new FormControl('', Validators.required);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map with the `required` property\n     * if the validation check fails, otherwise `null`.\n     *\n     */\n    Validators.required = function (control) {\n        return _super.required.call(this, control);\n    };\n    /**\n     * Validator that requires the control's value be true. This validator is commonly\n     * used for required checkboxes.\n     *\n     * ### Validate that the field value is true\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.requiredTrue);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map that contains the `required` property\n     * set to `true` if the validation check fails, otherwise `null`.\n     */\n    Validators.requiredTrue = function (control) {\n        return _super.requiredTrue.call(this, control);\n    };\n    /**\n     * Validator that requires the control's value pass an email validation test.\n     *\n     * ### Validate that the field matches a valid email pattern\n     *\n     * ```typescript\n     * const control = new FormControl('bad@', Validators.email);\n     *\n     * console.log(control.errors); // {email: true}\n     * ```\n     *\n     * @returns An error map with the `email` property\n     * if the validation check fails, otherwise `null`.\n     *\n     */\n    Validators.email = function (control) {\n        return _super.email.call(this, control);\n    };\n    /**\n     * Validator that requires the length of the control's value to be greater than or equal\n     * to the provided minimum length. This validator is also provided by default if you use the\n     * the HTML5 `minlength` attribute.\n     *\n     * ### Validate that the field has a minimum of 3 characters\n     *\n     * ```typescript\n     * const control = new FormControl('ng', Validators.minLength(3));\n     *\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n     * ```\n     *\n     * ```html\n     * <input minlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `minlength` if the validation check fails, otherwise `null`.\n     */\n    Validators.minLength = function (minLength) {\n        return _super.minLength.call(this, minLength);\n    };\n    /**\n     * Validator that requires the length of the control's value to be less than or equal\n     * to the provided maximum length. This validator is also provided by default if you use the\n     * the HTML5 `maxlength` attribute.\n     *\n     * ### Validate that the field has maximum of 5 characters\n     *\n     * ```typescript\n     * const control = new FormControl('Angular', Validators.maxLength(5));\n     *\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n     * ```\n     *\n     * ```html\n     * <input maxlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `maxlength` property if the validation check fails, otherwise `null`.\n     */\n    Validators.maxLength = function (maxLength) {\n        return _super.maxLength.call(this, maxLength);\n    };\n    /**\n     * Validator that requires the control's value to match a regex pattern. This validator is also\n     * provided by default if you use the HTML5 `pattern` attribute.\n     *\n     * Note that if a Regexp is provided, the Regexp is used as is to test the values. On the other\n     * hand, if a string is passed, the `^` character is prepended and the `$` character is\n     * appended to the provided string (if not already present), and the resulting regular\n     * expression is used to test the values.\n     *\n     * ### Validate that the field only contains letters or spaces\n     *\n     * ```typescript\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n     *\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n     * ```\n     *\n     * ```html\n     * <input pattern=\"[a-zA-Z ]*\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `pattern` property if the validation check fails, otherwise `null`.\n     */\n    Validators.pattern = function (pattern) {\n        return _super.pattern.call(this, pattern);\n    };\n    /**\n     * Validator that performs no operation.\n     */\n    Validators.nullValidator = function (control) {\n        return null;\n    };\n    Validators.compose = function (validators) {\n        return _super.compose.call(this, validators);\n    };\n    /**\n     * Compose multiple async validators into a single function that returns the union\n     * of the individual error objects for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\n     */\n    Validators.composeAsync = function (validators) {\n        return _super.composeAsync.call(this, validators);\n    };\n    /**\n     * At least one file should be.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    Validators.fileRequired = function (formControl) {\n        var e_1, _a;\n        if (!(formControl.value instanceof FormData)) {\n            return { fileRequired: true };\n        }\n        var files = [];\n        formControl.value.forEach(function (file) { return files.push(file); });\n        try {\n            for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {\n                var file = files_1_1.value;\n                if (file instanceof File) {\n                    return null;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return { fileRequired: true };\n    };\n    /**\n     * Minimal number of files.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    Validators.filesMinLength = function (minLength) {\n        return function (formControl) {\n            var value = formControl.value;\n            if (minLength < 1) {\n                return null;\n            }\n            if (!value || !(value instanceof FormData)) {\n                return { filesMinLength: { requiredLength: minLength, actualLength: 0 } };\n            }\n            var files = [];\n            value.forEach(function (file) { return files.push(file); });\n            var len = files.length;\n            if (len < minLength) {\n                return { filesMinLength: { requiredLength: minLength, actualLength: len } };\n            }\n            return null;\n        };\n    };\n    /**\n     * Maximal number of files.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    Validators.filesMaxLength = function (maxLength) {\n        return function (formControl) {\n            if (!(formControl.value instanceof FormData)) {\n                return null;\n            }\n            var files = [];\n            formControl.value.forEach(function (file) { return files.push(file); });\n            var len = files.length;\n            if (len > maxLength) {\n                return { filesMaxLength: { requiredLength: maxLength, actualLength: len } };\n            }\n            return null;\n        };\n    };\n    /**\n     * Maximal size of a file.\n     *\n     * **Note**: use this validator when `formControl.value` is an instance of `FormData` only.\n     */\n    Validators.fileMaxSize = function (maxSize) {\n        return function (formControl) {\n            var e_2, _a;\n            if (!(formControl.value instanceof FormData)) {\n                return null;\n            }\n            var files = [];\n            formControl.value.forEach(function (file) { return files.push(file); });\n            try {\n                for (var files_2 = __values(files), files_2_1 = files_2.next(); !files_2_1.done; files_2_1 = files_2.next()) {\n                    var file = files_2_1.value;\n                    if (file instanceof File && file.size > maxSize) {\n                        return { fileMaxSize: { requiredSize: maxSize, actualSize: file.size, file: file } };\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (files_2_1 && !files_2_1.done && (_a = files_2.return)) _a.call(files_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return null;\n        };\n    };\n    return Validators;\n}(Validators$1));\n\nvar sym = Symbol();\n/**\n * The default validators model, it includes almost all properties of `typeof Validators`,\n * excludes: `prototype`, `compose`, `composeAsync` and `nullValidator`.\n *\n * ### Usage\n *\n```ts\nconst formControl = new FormControl<string, ValidatorsModel>('some value');\n// OR\nconst formGroup = new FormGroup<any, ValidatorsModel>({});\n// OR\nconst formArray = new FormArray<any, ValidatorsModel>([]);\n```\n */\nvar ValidatorsModel = /** @class */ (function () {\n    function ValidatorsModel() {\n    }\n    return ValidatorsModel;\n}());\n\n/*\n * Public API Surface of forms\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FormArray, FormBuilder, FormControl, FormGroup, InputFileDirective, NgStackFormsModule, Validators, ValidatorsModel };\n//# sourceMappingURL=ng-stack-forms.js.map\n","<div *ngIf=\"errorValidation(control)\">\r\n    <ng-container *ngFor=\"let error of ObjectKeys(control.errors); let first = first\">\r\n        <span class=\"text-danger\">{{ errorMsgs[error] }}</span>\r\n    </ng-container>\r\n</div>","import { Component, Input } from '@angular/core';\r\nimport { FormControl, FormGroup } from '@ng-stack/forms';\r\nimport { FormUtil } from '@shared/validators/form.utils';\r\n\r\n\r\n@Component({\r\n  selector: 'app-input-validation',\r\n  templateUrl: \"./input-validation.html\",\r\n})\r\nexport class InputValidationComponent {\r\n    @Input() control: FormControl | FormGroup;\r\n    @Input() errorMsgs = {};\r\n    @Input() errorValidation = FormUtil.errorValidation;\r\n  \r\n    ObjectKeys = Object.keys;\r\n}\r\n","import { Directive, ElementRef, HostListener, Input } from '@angular/core';\r\nimport { NgControl } from '@angular/forms';\r\n\r\n@Directive({\r\n  selector: 'input[numbersOnly]'\r\n})\r\nexport class NumberDirective {\r\n\r\n  constructor(private _el: ElementRef) { }\r\n\r\n  @HostListener('input', ['$event']) onInputChange(event) {\r\n    const initalValue = this._el.nativeElement.value;\r\n    this._el.nativeElement.value = initalValue.replace(/[^0-9]*/g, '');\r\n    if ( initalValue !== this._el.nativeElement.value) {\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n}\r\n","import { AbstractControl } from '@angular/forms';\r\nimport { FormGroup, Validators } from '@ng-stack/forms';\r\n\r\n\r\nexport class FormUtil {\r\n\r\n  static errorValidation(formControl: AbstractControl) {\r\n    return formControl.invalid && formControl.touched;\r\n  }\r\n\r\n  static errorValidationDirty(formControl: AbstractControl) {\r\n    return formControl.invalid && formControl.touched && formControl.dirty;\r\n  }\r\n\r\n  static emptyOrNull(formControl: AbstractControl) {\r\n    return formControl.value === null || formControl.value === '';\r\n  }\r\n\r\n  static touchForm(form: FormGroup) {\r\n    form.markAsTouched();\r\n    Object.keys(form.controls).forEach(control => form.controls[control].markAsTouched());\r\n  }\r\n\r\n  static dirtyForm(form: FormGroup) {\r\n    form.markAsDirty();\r\n    Object.keys(form.controls).forEach(control => form.controls[control].markAsDirty());\r\n  }\r\n\r\n  static updateValidationInput(input: AbstractControl) {\r\n    input.updateValueAndValidity();\r\n    input.markAsDirty();\r\n    input.markAsTouched();\r\n  }\r\n\r\n  static requiredEnabled(control: AbstractControl) {\r\n    control.setValidators([ Validators.required ]);\r\n    control.enable();\r\n  }\r\n\r\n  static notRequiredEnabled(control: AbstractControl) {\r\n    control.clearValidators();\r\n    control.enable();\r\n  }\r\n\r\n  static notRequiredDisabled(control: AbstractControl) {\r\n    control.clearValidators();\r\n    control.disable();\r\n  }\r\n\r\n  static isoDateStringToBrDateString(isoDate: string) {\r\n    if (!isoDate || isoDate === '') {\r\n      return '';\r\n    }\r\n\r\n    const dateMs = Date.parse(isoDate);\r\n    const date = new Date(dateMs);\r\n\r\n    return (\r\n      date.getUTCDate().toString().padStart(2, '0') + '/' +\r\n      (date.getUTCMonth() + 1).toString().padStart(2, '0') + '/' +\r\n      date.getUTCFullYear().toString()\r\n    );\r\n  }\r\n\r\n  static brDateStringToIsoDateString(brDate: string) {\r\n    const date = brDate.split('/');\r\n\r\n    return date[2] + '-' + date[1] + '-' + date[0];\r\n  }\r\n\r\n  static validateForm(form: FormGroup) {\r\n    FormUtil.touchForm(form);\r\n    FormUtil.dirtyForm(form);\r\n\r\n    return form.valid;\r\n  }\r\n\r\n  static resetValueAndValidators(control: AbstractControl) {\r\n    control.reset();\r\n    control.clearValidators();\r\n    control.updateValueAndValidity();\r\n  }\r\n}\r\n"],"sourceRoot":""}